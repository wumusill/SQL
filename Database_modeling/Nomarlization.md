# 정규화
**********
## 1. 데이터베이스 이상 현상 (anomaly)
* 데이터베이스에서 삽입, 업데이트, 삭제를 제대로 할 수 없게 되는 경우

### (1) 삽입 이상
* 새로운 데이터를 자연스럽게 저장할 수 없는 경우

### (2) 업데이트 이상
* 데이터를 업데이트했을 때, 정확성을 지키기 어려워지는 경우

### (3) 삭제 이상
* 원하는 데이터만 자연스럽게 삭제할 수 없는 경우


<br>

## 2. 정규화 (Nomarlization)
* 데이터베이스의 테이블이 잘 만들어졌는지 평가하고, 잘 만들지 못한 테이블을 고쳐나가는 과정
* 테이블을 정규형(normal form)이라고 불리는 형태에 부합하게 만들어나감

### (1) 정규형 (Normal Form)
* 1NF, 2NF, 3NF........
* 순서에 따라 규칙이 누적
> 3NF까지만 부합해도 잘 정규화된 데이터베이스



### (2) 정규화의 이점
* 데이터베이스에서 삽입, 업데이트, 삭제 이상을 없앨 수 있음
* 새로운 종류의 데이터를 추가할 때 테이블 구조 수정을 많이 하지 않아도 됨
* 데이터베이스 구조를 단순화해서 사용자가 더 쉽게 이해할 수 있음

> 데이터 모델을 만들고, 데이터베이스에 구현하기 전에 적용하면 좋음



<br>

## 1. 1NF
* 테이블 안 모든 로우의 모든 컬럼 값들은 **나눌 수 없는 단일 값**이어야 함
* 테이블 안 모든 값들이 **무조건 하나의 값**만 가져야 함

### (1) 나눌 수 없는 단일 값 기준
* 표현자체가 불완전하다는 의견이 많지만, 컬럼 값을 사용할 때 **온전히 그 단위 자체로 사용하는지**, 저장하는 값들을 **일부분만 사용할 수도 있는지**를 판단하고 그것을 바탕으로 모델링 해야 함


### (2) 한 컬럼에 같은 종류의 값을 여러 개 저장하고 있을 때
* 해당 컬럼을 하나의 테이블로 분리해서 모델링
  * ex) 유저의 여러 전화번호

### (3) 한 컬럼에 다른 종류의 값을 여러 개 저장하고 있을 때
* 한 컬럼을 여러 개로 분리해서 모델링
  * ex) 외국인의 first name, middle name, last name

<br>

## 2. 2NF, 3NF 

### (1) 함수 종속성 (Functional Dependency)
* 테이블 안 `attribute`들 사이에서 생기는 관계
  * 테이블 A에 `attribute X`, `attribute Y`가 있고 `attribute Y`가 `attribute X`값에 따라 결정될 때, **Y는 X에 함수 종속성이 있다**고 함

####  이행적 함수 종속성
* 하나 이상의 `attribute`를 건너서 함수 종속성이 있는 경우 **이행적 함수 종속성이 있다**고 함


### (2) Candidate Key
* 하나의 로우를 특정 지을 수 있는 `attribute`들의 최소 집합
### prime attribute
* `candidate key`에 포함된 모든 `attribute`
* 그렇지 않은 `attribute`는 `non-prime attribute`


### (3) 2NF
* 1NF에 부합해야 함
* 테이블에 `candidate key`의 일부분에 대해서만 함수 종속성이 있는 `non-prime attribute`가 없어야 함



#### 2NF에 부합하기
* `non-prime attribute`이 `candidate key`의 전체에만 함수 종속성이 있도록 테이블을 분리
* `foreign key`를 사용해서 관계를 모델링

### (4) 3NF
* 2NF에 부합해야 함
* 테이블 안에 있는 모든 `attribute`들은 오직 `primary key`에 대해서만 함수 종속성이 있어야 함
  * 테이블의 모든 `attribute`는 직접적으로 테이블 `Entity`에 대한 내용이어야만 함
* 이행적 함수 종속성이 없어야 함



<br>

## 3. 비정규화
* 정규형에 부합하는 테이블을 정규형을 지키지 않게 바꾸는 걸 의미
* 성능 개선을 위해서
* 정규화가 안됐을 때는 모든 데이터가 한 테이블에 있기 때문에 오히려 조회가 더 빨리 실행될 수 있는 반면, 정규화가 된 데이터베이스에서 원하는 데이터를 조회할 때는 여러 테이블을 합쳐야하기 때문에 더 오래 걸릴 수 있음





* 하지만 여러 이상 현상들이 생기므로 아래 두 경우에만 고려
  1. 데이터가 너무 퍼져있어서 조회 연산의 성능 문제가 심각할 때
  2. 테이블을 삽입, 업데이트, 삭제하는 것보다 조회하는 용도로만 사용할 때


